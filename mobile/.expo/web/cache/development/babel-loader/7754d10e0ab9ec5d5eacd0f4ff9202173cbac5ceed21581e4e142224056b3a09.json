{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { CodedError } from 'expo-modules-core';\nvar GOOGLE_API_URL = 'https://maps.googleapis.com/maps/api/geocode/json';\nvar googleApiKey;\nexport function setGoogleApiKey(apiKey) {\n  googleApiKey = apiKey;\n}\nexport function googleGeocodeAsync(address) {\n  var result;\n  return _regeneratorRuntime.async(function googleGeocodeAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          assertGoogleApiKey();\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(requestGoogleApiAsync({\n            address: address\n          }));\n        case 3:\n          result = _context.sent;\n          if (!(result.status === 'ZERO_RESULTS')) {\n            _context.next = 6;\n            break;\n          }\n          return _context.abrupt(\"return\", []);\n        case 6:\n          assertGeocodeResults(result);\n          return _context.abrupt(\"return\", result.results.map(geocodingResultToLocation));\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function googleReverseGeocodeAsync(options) {\n  var result;\n  return _regeneratorRuntime.async(function googleReverseGeocodeAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          assertGoogleApiKey();\n          _context2.next = 3;\n          return _regeneratorRuntime.awrap(requestGoogleApiAsync({\n            latlng: options.latitude + \",\" + options.longitude\n          }));\n        case 3:\n          result = _context2.sent;\n          if (!(result.status === 'ZERO_RESULTS')) {\n            _context2.next = 6;\n            break;\n          }\n          return _context2.abrupt(\"return\", []);\n        case 6:\n          assertGeocodeResults(result);\n          return _context2.abrupt(\"return\", result.results.map(reverseGeocodingResultToAddress));\n        case 8:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nfunction assertGeocodeResults(resultObject) {\n  var status = resultObject.status,\n    error_message = resultObject.error_message;\n  if (status !== 'ZERO_RESULTS' && status !== 'OK') {\n    if (error_message) {\n      throw new CodedError(status, error_message);\n    } else if (status === 'UNKNOWN_ERROR') {\n      throw new CodedError(status, 'the request could not be processed due to a server error. The request may succeed if you try again.');\n    }\n    throw new CodedError(status, \"An error occurred during geocoding.\");\n  }\n}\nfunction assertGoogleApiKey() {\n  if (!googleApiKey) {\n    throw new Error('Google API key is required to use geocoding. Please set it using `setGoogleApiKey` method.');\n  }\n}\nfunction requestGoogleApiAsync(params) {\n  var query, result;\n  return _regeneratorRuntime.async(function requestGoogleApiAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          query = Object.entries(params).map(function (entry) {\n            return entry[0] + \"=\" + encodeURI(entry[1]);\n          }).join('&');\n          _context3.next = 3;\n          return _regeneratorRuntime.awrap(fetch(GOOGLE_API_URL + \"?key=\" + googleApiKey + \"&\" + query));\n        case 3:\n          result = _context3.sent;\n          _context3.next = 6;\n          return _regeneratorRuntime.awrap(result.json());\n        case 6:\n          return _context3.abrupt(\"return\", _context3.sent);\n        case 7:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nfunction geocodingResultToLocation(result) {\n  var location = result.geometry.location;\n  return {\n    latitude: location.lat,\n    longitude: location.lng\n  };\n}\nfunction reverseGeocodingResultToAddress(result) {\n  var address = {};\n  for (var _iterator = _createForOfIteratorHelperLoose(result.address_components), _step; !(_step = _iterator()).done;) {\n    var _ref = _step.value;\n    var long_name = _ref.long_name;\n    var short_name = _ref.short_name;\n    var types = _ref.types;\n    if (types.includes('locality')) {\n      address.city = long_name;\n      continue;\n    }\n    if (types.includes('sublocality')) {\n      address.district = long_name;\n      continue;\n    }\n    if (types.includes('street_number')) {\n      address.streetNumber = long_name;\n      continue;\n    }\n    if (types.includes('street_address') || types.includes('route')) {\n      address.street = long_name;\n      continue;\n    }\n    if (types.includes('administrative_area_level_1')) {\n      address.region = long_name;\n      continue;\n    }\n    if (types.includes('administrative_area_level_2')) {\n      address.subregion = long_name;\n      continue;\n    }\n    if (types.includes('country')) {\n      address.country = long_name;\n      address.isoCountryCode = short_name;\n      continue;\n    }\n    if (types.includes('postal_code')) {\n      address.postalCode = long_name;\n      continue;\n    }\n    if (types.includes('point_of_interest')) {\n      address.name = long_name;\n      continue;\n    }\n  }\n  if (!address.name) {\n    address.name = result.formatted_address.replace(/,.*$/, '');\n  }\n  return address;\n}","map":{"version":3,"names":["CodedError","GOOGLE_API_URL","googleApiKey","setGoogleApiKey","apiKey","googleGeocodeAsync","address","result","_regeneratorRuntime","async","googleGeocodeAsync$","_context","prev","next","assertGoogleApiKey","awrap","requestGoogleApiAsync","sent","status","abrupt","assertGeocodeResults","results","map","geocodingResultToLocation","stop","Promise","googleReverseGeocodeAsync","options","googleReverseGeocodeAsync$","_context2","latlng","latitude","longitude","reverseGeocodingResultToAddress","resultObject","error_message","Error","params","query","requestGoogleApiAsync$","_context3","Object","entries","entry","encodeURI","join","fetch","json","location","geometry","lat","lng","_iterator","_createForOfIteratorHelperLoose","address_components","_step","done","_ref","value","long_name","short_name","types","includes","city","district","streetNumber","street","region","subregion","country","isoCountryCode","postalCode","name","formatted_address","replace"],"sources":["C:\\Users\\Guilherme\\Documents\\MakeYourGO\\mobile\\node_modules\\expo-location\\src\\LocationGoogleGeocoding.ts"],"sourcesContent":["import { CodedError } from 'expo-modules-core';\n\nimport { LocationGeocodedAddress, LocationGeocodedLocation } from './Location.types';\n\nconst GOOGLE_API_URL = 'https://maps.googleapis.com/maps/api/geocode/json';\nlet googleApiKey;\n\ntype GoogleApiGeocodingAddressComponent = {\n  long_name: string;\n  short_name: string;\n  types: string[];\n};\n\ntype GoogleApiGeocodingResult = {\n  address_components: GoogleApiGeocodingAddressComponent[];\n  formatted_address: string;\n  geometry: {\n    location: {\n      lat: number;\n      lng: number;\n    };\n  };\n};\n\ntype GoogleApiGeocodingResponse = {\n  results: GoogleApiGeocodingResult[];\n  status: string;\n};\n\n// @needsAudit\n/**\n * Sets a Google API Key for using Google Maps Geocoding API which is used by default on Web\n * platform and can be enabled through `useGoogleMaps` option of `geocodeAsync` and `reverseGeocodeAsync`\n * methods. It might be useful for Android devices that do not have Google Play Services, hence no\n * Geocoder Service.\n * @param apiKey Google API key obtained from Google API Console. This API key must have `Geocoding API`\n * enabled, otherwise your geocoding requests will be denied.\n */\nexport function setGoogleApiKey(apiKey: string) {\n  googleApiKey = apiKey;\n}\n\nexport async function googleGeocodeAsync(address: string): Promise<LocationGeocodedLocation[]> {\n  assertGoogleApiKey();\n\n  const result = await requestGoogleApiAsync({ address });\n\n  if (result.status === 'ZERO_RESULTS') {\n    return [];\n  }\n  assertGeocodeResults(result);\n  return result.results.map(geocodingResultToLocation);\n}\n\nexport async function googleReverseGeocodeAsync(options: {\n  latitude: number;\n  longitude: number;\n}): Promise<LocationGeocodedAddress[]> {\n  assertGoogleApiKey();\n\n  const result = await requestGoogleApiAsync({\n    latlng: `${options.latitude},${options.longitude}`,\n  });\n\n  if (result.status === 'ZERO_RESULTS') {\n    return [];\n  }\n  assertGeocodeResults(result);\n  return result.results.map(reverseGeocodingResultToAddress);\n}\n\n// https://developers.google.com/maps/documentation/geocoding/intro\nfunction assertGeocodeResults(resultObject: any): void {\n  const { status, error_message } = resultObject;\n  if (status !== 'ZERO_RESULTS' && status !== 'OK') {\n    if (error_message) {\n      throw new CodedError(status, error_message);\n    } else if (status === 'UNKNOWN_ERROR') {\n      throw new CodedError(\n        status,\n        'the request could not be processed due to a server error. The request may succeed if you try again.'\n      );\n    }\n    throw new CodedError(status, `An error occurred during geocoding.`);\n  }\n}\n\n/**\n * Makes sure the Google API key is set.\n */\nfunction assertGoogleApiKey() {\n  if (!googleApiKey) {\n    throw new Error(\n      'Google API key is required to use geocoding. Please set it using `setGoogleApiKey` method.'\n    );\n  }\n}\n\n/**\n * Generic and handy method for sending requests to Google Maps API endpoint.\n */\nasync function requestGoogleApiAsync(\n  params: { address: string } | { latlng: string }\n): Promise<GoogleApiGeocodingResponse> {\n  const query = Object.entries(params)\n    .map((entry) => `${entry[0]}=${encodeURI(entry[1])}`)\n    .join('&');\n  const result = await fetch(`${GOOGLE_API_URL}?key=${googleApiKey}&${query}`);\n  return await result.json();\n}\n\n/**\n * Converts Google's result to the location object.\n */\nfunction geocodingResultToLocation(result: GoogleApiGeocodingResult): LocationGeocodedLocation {\n  const { location } = result.geometry;\n  return {\n    latitude: location.lat,\n    longitude: location.lng,\n  };\n}\n\n/**\n * Converts Google's result to address object.\n */\nfunction reverseGeocodingResultToAddress(\n  result: GoogleApiGeocodingResult\n): LocationGeocodedAddress {\n  const address: Partial<LocationGeocodedAddress> = {};\n\n  for (const { long_name, short_name, types } of result.address_components) {\n    if (types.includes('locality')) {\n      address.city = long_name;\n      continue;\n    }\n    if (types.includes('sublocality')) {\n      address.district = long_name;\n      continue;\n    }\n    if (types.includes('street_number')) {\n      address.streetNumber = long_name;\n      continue;\n    }\n    if (types.includes('street_address') || types.includes('route')) {\n      address.street = long_name;\n      continue;\n    }\n    if (types.includes('administrative_area_level_1')) {\n      address.region = long_name;\n      continue;\n    }\n    if (types.includes('administrative_area_level_2')) {\n      address.subregion = long_name;\n      continue;\n    }\n    if (types.includes('country')) {\n      address.country = long_name;\n      address.isoCountryCode = short_name;\n      continue;\n    }\n    if (types.includes('postal_code')) {\n      address.postalCode = long_name;\n      continue;\n    }\n    if (types.includes('point_of_interest')) {\n      address.name = long_name;\n      continue;\n    }\n  }\n  if (!address.name) {\n    address.name = result.formatted_address.replace(/,.*$/, '');\n  }\n  return address as LocationGeocodedAddress;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}