{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { PermissionStatus, createPermissionHook, Platform } from 'expo-modules-core';\nimport ExpoLocation from \"./ExpoLocation\";\nimport { LocationAccuracy, LocationActivityType, LocationGeofencingEventType, LocationGeofencingRegionState } from \"./Location.types\";\nimport { LocationEventEmitter } from \"./LocationEventEmitter\";\nimport { setGoogleApiKey, googleGeocodeAsync, googleReverseGeocodeAsync } from \"./LocationGoogleGeocoding\";\nimport { LocationSubscriber, HeadingSubscriber, _getCurrentWatchId } from \"./LocationSubscribers\";\nexport function getProviderStatusAsync() {\n  return _regeneratorRuntime.async(function getProviderStatusAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", ExpoLocation.getProviderStatusAsync());\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function enableNetworkProviderAsync() {\n  return _regeneratorRuntime.async(function enableNetworkProviderAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!(Platform.OS === 'android')) {\n            _context2.next = 2;\n            break;\n          }\n          return _context2.abrupt(\"return\", ExpoLocation.enableNetworkProviderAsync());\n        case 2:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getCurrentPositionAsync() {\n  var options,\n    _args3 = arguments;\n  return _regeneratorRuntime.async(function getCurrentPositionAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};\n          return _context3.abrupt(\"return\", ExpoLocation.getCurrentPositionAsync(options));\n        case 2:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getLastKnownPositionAsync() {\n  var options,\n    _args4 = arguments;\n  return _regeneratorRuntime.async(function getLastKnownPositionAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};\n          return _context4.abrupt(\"return\", ExpoLocation.getLastKnownPositionAsync(options));\n        case 2:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function watchPositionAsync(options, callback) {\n  var watchId;\n  return _regeneratorRuntime.async(function watchPositionAsync$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          watchId = LocationSubscriber.registerCallback(callback);\n          _context5.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.watchPositionImplAsync(watchId, options));\n        case 3:\n          return _context5.abrupt(\"return\", {\n            remove: function remove() {\n              LocationSubscriber.unregisterCallback(watchId);\n            }\n          });\n        case 4:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getHeadingAsync() {\n  return _regeneratorRuntime.async(function getHeadingAsync$(_context7) {\n    while (1) {\n      switch (_context7.prev = _context7.next) {\n        case 0:\n          return _context7.abrupt(\"return\", new Promise(function _callee(resolve) {\n            var tries, subscription;\n            return _regeneratorRuntime.async(function _callee$(_context6) {\n              while (1) {\n                switch (_context6.prev = _context6.next) {\n                  case 0:\n                    tries = 0;\n                    _context6.next = 3;\n                    return _regeneratorRuntime.awrap(watchHeadingAsync(function (heading) {\n                      if (heading.accuracy > 1 || tries > 5) {\n                        subscription.remove();\n                        resolve(heading);\n                      } else {\n                        tries += 1;\n                      }\n                    }));\n                  case 3:\n                    subscription = _context6.sent;\n                  case 4:\n                  case \"end\":\n                    return _context6.stop();\n                }\n              }\n            }, null, null, null, Promise);\n          }));\n        case 1:\n        case \"end\":\n          return _context7.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function watchHeadingAsync(callback) {\n  var watchId;\n  return _regeneratorRuntime.async(function watchHeadingAsync$(_context8) {\n    while (1) {\n      switch (_context8.prev = _context8.next) {\n        case 0:\n          watchId = HeadingSubscriber.registerCallback(callback);\n          _context8.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.watchDeviceHeading(watchId));\n        case 3:\n          return _context8.abrupt(\"return\", {\n            remove: function remove() {\n              HeadingSubscriber.unregisterCallback(watchId);\n            }\n          });\n        case 4:\n        case \"end\":\n          return _context8.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function geocodeAsync(address, options) {\n  return _regeneratorRuntime.async(function geocodeAsync$(_context9) {\n    while (1) {\n      switch (_context9.prev = _context9.next) {\n        case 0:\n          if (!(typeof address !== 'string')) {\n            _context9.next = 2;\n            break;\n          }\n          throw new TypeError(\"Address to geocode must be a string. Got \" + address + \" instead.\");\n        case 2:\n          if (!(options != null && options.useGoogleMaps || Platform.OS === 'web')) {\n            _context9.next = 6;\n            break;\n          }\n          _context9.next = 5;\n          return _regeneratorRuntime.awrap(googleGeocodeAsync(address));\n        case 5:\n          return _context9.abrupt(\"return\", _context9.sent);\n        case 6:\n          _context9.next = 8;\n          return _regeneratorRuntime.awrap(ExpoLocation.geocodeAsync(address));\n        case 8:\n          return _context9.abrupt(\"return\", _context9.sent);\n        case 9:\n        case \"end\":\n          return _context9.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function reverseGeocodeAsync(location, options) {\n  return _regeneratorRuntime.async(function reverseGeocodeAsync$(_context10) {\n    while (1) {\n      switch (_context10.prev = _context10.next) {\n        case 0:\n          if (!(typeof location.latitude !== 'number' || typeof location.longitude !== 'number')) {\n            _context10.next = 2;\n            break;\n          }\n          throw new TypeError('Location to reverse-geocode must be an object with number properties `latitude` and `longitude`.');\n        case 2:\n          if (!(options != null && options.useGoogleMaps || Platform.OS === 'web')) {\n            _context10.next = 6;\n            break;\n          }\n          _context10.next = 5;\n          return _regeneratorRuntime.awrap(googleReverseGeocodeAsync(location));\n        case 5:\n          return _context10.abrupt(\"return\", _context10.sent);\n        case 6:\n          _context10.next = 8;\n          return _regeneratorRuntime.awrap(ExpoLocation.reverseGeocodeAsync(location));\n        case 8:\n          return _context10.abrupt(\"return\", _context10.sent);\n        case 9:\n        case \"end\":\n          return _context10.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getPermissionsAsync() {\n  return _regeneratorRuntime.async(function getPermissionsAsync$(_context11) {\n    while (1) {\n      switch (_context11.prev = _context11.next) {\n        case 0:\n          console.warn(\"\\\"getPermissionsAsync()\\\" is now deprecated. Please use \\\"getForegroundPermissionsAsync()\\\" or \\\"getBackgroundPermissionsAsync()\\\" instead.\");\n          _context11.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.getPermissionsAsync());\n        case 3:\n          return _context11.abrupt(\"return\", _context11.sent);\n        case 4:\n        case \"end\":\n          return _context11.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function requestPermissionsAsync() {\n  return _regeneratorRuntime.async(function requestPermissionsAsync$(_context12) {\n    while (1) {\n      switch (_context12.prev = _context12.next) {\n        case 0:\n          console.warn(\"\\\"requestPermissionsAsync()\\\" is now deprecated. Please use \\\"requestForegroundPermissionsAsync()\\\" or \\\"requestBackgroundPermissionsAsync()\\\" instead.\");\n          _context12.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.requestPermissionsAsync());\n        case 3:\n          return _context12.abrupt(\"return\", _context12.sent);\n        case 4:\n        case \"end\":\n          return _context12.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getForegroundPermissionsAsync() {\n  return _regeneratorRuntime.async(function getForegroundPermissionsAsync$(_context13) {\n    while (1) {\n      switch (_context13.prev = _context13.next) {\n        case 0:\n          _context13.next = 2;\n          return _regeneratorRuntime.awrap(ExpoLocation.getForegroundPermissionsAsync());\n        case 2:\n          return _context13.abrupt(\"return\", _context13.sent);\n        case 3:\n        case \"end\":\n          return _context13.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function requestForegroundPermissionsAsync() {\n  return _regeneratorRuntime.async(function requestForegroundPermissionsAsync$(_context14) {\n    while (1) {\n      switch (_context14.prev = _context14.next) {\n        case 0:\n          _context14.next = 2;\n          return _regeneratorRuntime.awrap(ExpoLocation.requestForegroundPermissionsAsync());\n        case 2:\n          return _context14.abrupt(\"return\", _context14.sent);\n        case 3:\n        case \"end\":\n          return _context14.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport var useForegroundPermissions = createPermissionHook({\n  getMethod: getForegroundPermissionsAsync,\n  requestMethod: requestForegroundPermissionsAsync\n});\nexport function getBackgroundPermissionsAsync() {\n  return _regeneratorRuntime.async(function getBackgroundPermissionsAsync$(_context15) {\n    while (1) {\n      switch (_context15.prev = _context15.next) {\n        case 0:\n          _context15.next = 2;\n          return _regeneratorRuntime.awrap(ExpoLocation.getBackgroundPermissionsAsync());\n        case 2:\n          return _context15.abrupt(\"return\", _context15.sent);\n        case 3:\n        case \"end\":\n          return _context15.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function requestBackgroundPermissionsAsync() {\n  return _regeneratorRuntime.async(function requestBackgroundPermissionsAsync$(_context16) {\n    while (1) {\n      switch (_context16.prev = _context16.next) {\n        case 0:\n          _context16.next = 2;\n          return _regeneratorRuntime.awrap(ExpoLocation.requestBackgroundPermissionsAsync());\n        case 2:\n          return _context16.abrupt(\"return\", _context16.sent);\n        case 3:\n        case \"end\":\n          return _context16.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport var useBackgroundPermissions = createPermissionHook({\n  getMethod: getBackgroundPermissionsAsync,\n  requestMethod: requestBackgroundPermissionsAsync\n});\nexport function hasServicesEnabledAsync() {\n  return _regeneratorRuntime.async(function hasServicesEnabledAsync$(_context17) {\n    while (1) {\n      switch (_context17.prev = _context17.next) {\n        case 0:\n          _context17.next = 2;\n          return _regeneratorRuntime.awrap(ExpoLocation.hasServicesEnabledAsync());\n        case 2:\n          return _context17.abrupt(\"return\", _context17.sent);\n        case 3:\n        case \"end\":\n          return _context17.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new Error(\"`taskName` must be a non-empty string. Got \" + taskName + \" instead.\");\n  }\n}\nexport function isBackgroundLocationAvailableAsync() {\n  var providerStatus;\n  return _regeneratorRuntime.async(function isBackgroundLocationAvailableAsync$(_context18) {\n    while (1) {\n      switch (_context18.prev = _context18.next) {\n        case 0:\n          _context18.next = 2;\n          return _regeneratorRuntime.awrap(getProviderStatusAsync());\n        case 2:\n          providerStatus = _context18.sent;\n          return _context18.abrupt(\"return\", providerStatus.backgroundModeEnabled);\n        case 4:\n        case \"end\":\n          return _context18.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function startLocationUpdatesAsync(taskName) {\n  var options,\n    _args19 = arguments;\n  return _regeneratorRuntime.async(function startLocationUpdatesAsync$(_context19) {\n    while (1) {\n      switch (_context19.prev = _context19.next) {\n        case 0:\n          options = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : {\n            accuracy: LocationAccuracy.Balanced\n          };\n          _validateTaskName(taskName);\n          _context19.next = 4;\n          return _regeneratorRuntime.awrap(ExpoLocation.startLocationUpdatesAsync(taskName, options));\n        case 4:\n        case \"end\":\n          return _context19.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function stopLocationUpdatesAsync(taskName) {\n  return _regeneratorRuntime.async(function stopLocationUpdatesAsync$(_context20) {\n    while (1) {\n      switch (_context20.prev = _context20.next) {\n        case 0:\n          _validateTaskName(taskName);\n          _context20.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.stopLocationUpdatesAsync(taskName));\n        case 3:\n        case \"end\":\n          return _context20.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function hasStartedLocationUpdatesAsync(taskName) {\n  return _regeneratorRuntime.async(function hasStartedLocationUpdatesAsync$(_context21) {\n    while (1) {\n      switch (_context21.prev = _context21.next) {\n        case 0:\n          _validateTaskName(taskName);\n          return _context21.abrupt(\"return\", ExpoLocation.hasStartedLocationUpdatesAsync(taskName));\n        case 2:\n        case \"end\":\n          return _context21.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nfunction _validateRegions(regions) {\n  if (!regions || regions.length === 0) {\n    throw new Error('Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions');\n  }\n  for (var _iterator = _createForOfIteratorHelperLoose(regions), _step; !(_step = _iterator()).done;) {\n    var region = _step.value;\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(\"Region's latitude must be a number. Got '\" + region.latitude + \"' instead.\");\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\"Region's longitude must be a number. Got '\" + region.longitude + \"' instead.\");\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(\"Region's radius must be a number. Got '\" + region.radius + \"' instead.\");\n    }\n  }\n}\nexport function startGeofencingAsync(taskName) {\n  var regions,\n    _args22 = arguments;\n  return _regeneratorRuntime.async(function startGeofencingAsync$(_context22) {\n    while (1) {\n      switch (_context22.prev = _context22.next) {\n        case 0:\n          regions = _args22.length > 1 && _args22[1] !== undefined ? _args22[1] : [];\n          _validateTaskName(taskName);\n          _validateRegions(regions);\n          _context22.next = 5;\n          return _regeneratorRuntime.awrap(ExpoLocation.startGeofencingAsync(taskName, {\n            regions: regions\n          }));\n        case 5:\n        case \"end\":\n          return _context22.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function stopGeofencingAsync(taskName) {\n  return _regeneratorRuntime.async(function stopGeofencingAsync$(_context23) {\n    while (1) {\n      switch (_context23.prev = _context23.next) {\n        case 0:\n          _validateTaskName(taskName);\n          _context23.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.stopGeofencingAsync(taskName));\n        case 3:\n        case \"end\":\n          return _context23.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function hasStartedGeofencingAsync(taskName) {\n  return _regeneratorRuntime.async(function hasStartedGeofencingAsync$(_context24) {\n    while (1) {\n      switch (_context24.prev = _context24.next) {\n        case 0:\n          _validateTaskName(taskName);\n          return _context24.abrupt(\"return\", ExpoLocation.hasStartedGeofencingAsync(taskName));\n        case 2:\n        case \"end\":\n          return _context24.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport { LocationEventEmitter as EventEmitter, _getCurrentWatchId };\nexport { LocationAccuracy as Accuracy, LocationActivityType as ActivityType, LocationGeofencingEventType as GeofencingEventType, LocationGeofencingRegionState as GeofencingRegionState, PermissionStatus, setGoogleApiKey };\nexport { installWebGeolocationPolyfill } from \"./GeolocationPolyfill\";\nexport * from \"./Location.types\";","map":{"version":3,"names":["PermissionStatus","createPermissionHook","Platform","ExpoLocation","LocationAccuracy","LocationActivityType","LocationGeofencingEventType","LocationGeofencingRegionState","LocationEventEmitter","setGoogleApiKey","googleGeocodeAsync","googleReverseGeocodeAsync","LocationSubscriber","HeadingSubscriber","_getCurrentWatchId","getProviderStatusAsync","_regeneratorRuntime","async","getProviderStatusAsync$","_context","prev","next","abrupt","stop","Promise","enableNetworkProviderAsync","enableNetworkProviderAsync$","_context2","OS","getCurrentPositionAsync","options","_args3","arguments","getCurrentPositionAsync$","_context3","length","undefined","getLastKnownPositionAsync","_args4","getLastKnownPositionAsync$","_context4","watchPositionAsync","callback","watchId","watchPositionAsync$","_context5","registerCallback","awrap","watchPositionImplAsync","remove","unregisterCallback","getHeadingAsync","getHeadingAsync$","_context7","_callee","resolve","tries","subscription","_callee$","_context6","watchHeadingAsync","heading","accuracy","sent","watchHeadingAsync$","_context8","watchDeviceHeading","geocodeAsync","address","geocodeAsync$","_context9","TypeError","useGoogleMaps","reverseGeocodeAsync","location","reverseGeocodeAsync$","_context10","latitude","longitude","getPermissionsAsync","getPermissionsAsync$","_context11","console","warn","requestPermissionsAsync","requestPermissionsAsync$","_context12","getForegroundPermissionsAsync","getForegroundPermissionsAsync$","_context13","requestForegroundPermissionsAsync","requestForegroundPermissionsAsync$","_context14","useForegroundPermissions","getMethod","requestMethod","getBackgroundPermissionsAsync","getBackgroundPermissionsAsync$","_context15","requestBackgroundPermissionsAsync","requestBackgroundPermissionsAsync$","_context16","useBackgroundPermissions","hasServicesEnabledAsync","hasServicesEnabledAsync$","_context17","_validateTaskName","taskName","Error","isBackgroundLocationAvailableAsync","providerStatus","isBackgroundLocationAvailableAsync$","_context18","backgroundModeEnabled","startLocationUpdatesAsync","_args19","startLocationUpdatesAsync$","_context19","Balanced","stopLocationUpdatesAsync","stopLocationUpdatesAsync$","_context20","hasStartedLocationUpdatesAsync","hasStartedLocationUpdatesAsync$","_context21","_validateRegions","regions","_iterator","_createForOfIteratorHelperLoose","_step","done","region","value","radius","startGeofencingAsync","_args22","startGeofencingAsync$","_context22","stopGeofencingAsync","stopGeofencingAsync$","_context23","hasStartedGeofencingAsync","hasStartedGeofencingAsync$","_context24","EventEmitter","Accuracy","ActivityType","GeofencingEventType","GeofencingRegionState","installWebGeolocationPolyfill"],"sources":["C:\\Users\\Guilherme\\Documents\\MakeYourGO\\mobile\\node_modules\\expo-location\\src\\Location.ts"],"sourcesContent":["import {\n  PermissionStatus,\n  PermissionResponse,\n  PermissionHookOptions,\n  createPermissionHook,\n  Platform,\n} from 'expo-modules-core';\n\nimport ExpoLocation from './ExpoLocation';\nimport {\n  LocationAccuracy,\n  LocationCallback,\n  LocationGeocodedAddress,\n  LocationGeocodedLocation,\n  LocationHeadingCallback,\n  LocationHeadingObject,\n  LocationLastKnownOptions,\n  LocationObject,\n  LocationOptions,\n  LocationPermissionResponse,\n  LocationProviderStatus,\n  LocationRegion,\n  LocationSubscription,\n  LocationTaskOptions,\n  LocationActivityType,\n  LocationGeofencingEventType,\n  LocationGeofencingRegionState,\n  LocationGeocodingOptions,\n} from './Location.types';\nimport { LocationEventEmitter } from './LocationEventEmitter';\nimport {\n  setGoogleApiKey,\n  googleGeocodeAsync,\n  googleReverseGeocodeAsync,\n} from './LocationGoogleGeocoding';\nimport { LocationSubscriber, HeadingSubscriber, _getCurrentWatchId } from './LocationSubscribers';\n\n// @needsAudit\n/**\n * Check status of location providers.\n * @return A promise which fulfills with an object of type [LocationProviderStatus](#locationproviderstatus).\n */\nexport async function getProviderStatusAsync(): Promise<LocationProviderStatus> {\n  return ExpoLocation.getProviderStatusAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to turn on high accuracy location mode which enables network provider that uses\n * Google Play services to improve location accuracy and location-based services.\n * @return A promise resolving as soon as the user accepts the dialog. Rejects if denied.\n */\nexport async function enableNetworkProviderAsync(): Promise<void> {\n  // If network provider is disabled (user's location mode is set to \"Device only\"),\n  // Android's location provider may not give you any results. Use this method in order to ask the user\n  // to change the location mode to \"High accuracy\" which uses Google Play services and enables network provider.\n  // `getCurrentPositionAsync` and `watchPositionAsync` are doing it automatically anyway.\n\n  if (Platform.OS === 'android') {\n    return ExpoLocation.enableNetworkProviderAsync();\n  }\n}\n\n// @needsAudit\n/**\n * Requests for one-time delivery of the user's current location.\n * Depending on given `accuracy` option it may take some time to resolve,\n * especially when you're inside a building.\n * > __Note:__ Calling it causes the location manager to obtain a location fix which may take several\n * > seconds. Consider using [`Location.getLastKnownPositionAsync`](#locationgetlastknownpositionasyncoptions)\n * > if you expect to get a quick response and high accuracy is not required.\n * @param options\n * @return A promise which fulfills with an object of type [`LocationObject`](#locationobject).\n */\nexport async function getCurrentPositionAsync(\n  options: LocationOptions = {}\n): Promise<LocationObject> {\n  return ExpoLocation.getCurrentPositionAsync(options);\n}\n\n// @needsAudit\n/**\n * Gets the last known position of the device or `null` if it's not available or doesn't match given\n * requirements such as maximum age or required accuracy.\n * It's considered to be faster than `getCurrentPositionAsync` as it doesn't request for the current\n * location, but keep in mind the returned location may not be up-to-date.\n * @param options\n * @return A promise which fulfills with an object of type [LocationObject](#locationobject) or\n * `null` if it's not available or doesn't match given requirements such as maximum age or required\n * accuracy.\n */\nexport async function getLastKnownPositionAsync(\n  options: LocationLastKnownOptions = {}\n): Promise<LocationObject | null> {\n  return ExpoLocation.getLastKnownPositionAsync(options);\n}\n\n// @needsAudit\n/**\n * Subscribe to location updates from the device. Please note that updates will only occur while the\n * application is in the foreground. To get location updates while in background you'll need to use\n * [Location.startLocationUpdatesAsync](#locationstartlocationupdatesasynctaskname-options).\n * @param options\n * @param callback This function is called on each location update. It receives an object of type\n * [`LocationObject`](#locationobject) as the first argument.\n * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.\n */\nexport async function watchPositionAsync(\n  options: LocationOptions,\n  callback: LocationCallback\n): Promise<LocationSubscription> {\n  const watchId = LocationSubscriber.registerCallback(callback);\n  await ExpoLocation.watchPositionImplAsync(watchId, options);\n\n  return {\n    remove() {\n      LocationSubscriber.unregisterCallback(watchId);\n    },\n  };\n}\n\n// @needsAudit\n/**\n * Gets the current heading information from the device. To simplify, it calls `watchHeadingAsync`\n * and waits for a couple of updates, and then returns the one that is accurate enough.\n * @return A promise which fulfills with an object of type [LocationHeadingObject](#locationheadingobject).\n */\nexport async function getHeadingAsync(): Promise<LocationHeadingObject> {\n  return new Promise(async (resolve) => {\n    let tries = 0;\n\n    const subscription = await watchHeadingAsync((heading) => {\n      if (heading.accuracy > 1 || tries > 5) {\n        subscription.remove();\n        resolve(heading);\n      } else {\n        tries += 1;\n      }\n    });\n  });\n}\n\n// @needsAudit\n/**\n * Subscribe to compass updates from the device.\n * @param callback This function is called on each compass update. It receives an object of type\n * [LocationHeadingObject](#locationheadingobject) as the first argument.\n * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.\n */\nexport async function watchHeadingAsync(\n  callback: LocationHeadingCallback\n): Promise<LocationSubscription> {\n  const watchId = HeadingSubscriber.registerCallback(callback);\n  await ExpoLocation.watchDeviceHeading(watchId);\n\n  return {\n    remove() {\n      HeadingSubscriber.unregisterCallback(watchId);\n    },\n  };\n}\n\n// @needsAudit\n/**\n * Geocode an address string to latitude-longitude location.\n * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many\n * > requests at a time can result in an error, so they have to be managed properly.\n * > It's also discouraged to use geocoding while the app is in the background and its results won't\n * > be shown to the user immediately.\n *\n * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user\n * > before geocoding can be used.\n * @param address A string representing address, eg. `\"Baker Street London\"`.\n * @param options\n * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedLocation`](#locationgeocodedlocation) objects.\n */\nexport async function geocodeAsync(\n  address: string,\n  options?: LocationGeocodingOptions\n): Promise<LocationGeocodedLocation[]> {\n  if (typeof address !== 'string') {\n    throw new TypeError(`Address to geocode must be a string. Got ${address} instead.`);\n  }\n  if (options?.useGoogleMaps || Platform.OS === 'web') {\n    return await googleGeocodeAsync(address);\n  }\n  return await ExpoLocation.geocodeAsync(address);\n}\n\n// @needsAudit\n/**\n * Reverse geocode a location to postal address.\n * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many\n * > requests at a time can result in an error, so they have to be managed properly.\n * > It's also discouraged to use geocoding while the app is in the background and its results won't\n * > be shown to the user immediately.\n *\n * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user\n * > before geocoding can be used.\n * @param location An object representing a location.\n * @param options\n * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedAddress`](#locationgeocodedaddress) objects.\n */\nexport async function reverseGeocodeAsync(\n  location: Pick<LocationGeocodedLocation, 'latitude' | 'longitude'>,\n  options?: LocationGeocodingOptions\n): Promise<LocationGeocodedAddress[]> {\n  if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {\n    throw new TypeError(\n      'Location to reverse-geocode must be an object with number properties `latitude` and `longitude`.'\n    );\n  }\n  if (options?.useGoogleMaps || Platform.OS === 'web') {\n    return await googleReverseGeocodeAsync(location);\n  }\n  return await ExpoLocation.reverseGeocodeAsync(location);\n}\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location.\n * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).\n * @deprecated Use [`getForegroundPermissionsAsync`](#locationgetforegroundpermissionsasync) or [`getBackgroundPermissionsAsync`](#locationgetbackgroundpermissionsasync) instead.\n */\nexport async function getPermissionsAsync(): Promise<LocationPermissionResponse> {\n  console.warn(\n    `\"getPermissionsAsync()\" is now deprecated. Please use \"getForegroundPermissionsAsync()\" or \"getBackgroundPermissionsAsync()\" instead.`\n  );\n  return await ExpoLocation.getPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location.\n * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).\n * @deprecated Use [`requestForegroundPermissionsAsync`](#locationrequestforegroundpermissionsasync) or [`requestBackgroundPermissionsAsync`](#locationrequestbackgroundpermissionsasync) instead.\n */\nexport async function requestPermissionsAsync(): Promise<LocationPermissionResponse> {\n  console.warn(\n    `\"requestPermissionsAsync()\" is now deprecated. Please use \"requestForegroundPermissionsAsync()\" or \"requestBackgroundPermissionsAsync()\" instead.`\n  );\n\n  return await ExpoLocation.requestPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location while the app is in the foreground.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function getForegroundPermissionsAsync(): Promise<LocationPermissionResponse> {\n  return await ExpoLocation.getForegroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location while the app is in the foreground.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function requestForegroundPermissionsAsync(): Promise<LocationPermissionResponse> {\n  return await ExpoLocation.requestForegroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Check or request permissions for the foreground location.\n * This uses both `requestForegroundPermissionsAsync` and `getForegroundPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Location.useForegroundPermissions();\n * ```\n */\nexport const useForegroundPermissions = createPermissionHook({\n  getMethod: getForegroundPermissionsAsync,\n  requestMethod: requestForegroundPermissionsAsync,\n});\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location while the app is in the background.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function getBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.getBackgroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location while the app is in the background.\n * On __Android 11 or higher__: this method will open the system settings page - before that happens\n * you should explain to the user why your application needs background location permission.\n * For example, you can use `Modal` component from `react-native` to do that.\n * > __Note__: Foreground permissions should be granted before asking for the background permissions\n * (your app can't obtain background permission without foreground permission).\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function requestBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.requestBackgroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Check or request permissions for the foreground location.\n * This uses both `requestBackgroundPermissionsAsync` and `getBackgroundPermissionsAsync` to\n * interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Location.useBackgroundPermissions();\n * ```\n */\nexport const useBackgroundPermissions = createPermissionHook({\n  getMethod: getBackgroundPermissionsAsync,\n  requestMethod: requestBackgroundPermissionsAsync,\n});\n\n// --- Location service\n\n// @needsAudit\n/**\n * Checks whether location services are enabled by the user.\n * @return A promise which fulfills to `true` if location services are enabled on the device,\n * or `false` if not.\n */\nexport async function hasServicesEnabledAsync(): Promise<boolean> {\n  return await ExpoLocation.hasServicesEnabledAsync();\n}\n\n// --- Background location updates\n\nfunction _validateTaskName(taskName: string) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new Error(`\\`taskName\\` must be a non-empty string. Got ${taskName} instead.`);\n  }\n}\n\n// @docsMissing\nexport async function isBackgroundLocationAvailableAsync(): Promise<boolean> {\n  const providerStatus = await getProviderStatusAsync();\n  return providerStatus.backgroundModeEnabled;\n}\n\n// @needsAudit\n/**\n * Registers for receiving location updates that can also come when the app is in the background.\n * @param taskName Name of the task receiving location updates.\n * @param options An object of options passed to the location manager.\n * @return A promise resolving once the task with location updates is registered.\n *\n * # Task parameters\n *\n * Background location task will be receiving following data:\n * - `locations` - An array of the new locations.\n *\n * ```ts\n * import * as TaskManager from 'expo-task-manager';\n *\n * TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { locations }, error }) => {\n *  if (error) {\n *    // check `error.message` for more details.\n *    return;\n *  }\n *  console.log('Received new locations', locations);\n * });\n * ```\n */\nexport async function startLocationUpdatesAsync(\n  taskName: string,\n  options: LocationTaskOptions = { accuracy: LocationAccuracy.Balanced }\n): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.startLocationUpdatesAsync(taskName, options);\n}\n\n// @needsAudit\n/**\n * Stops geofencing for specified task.\n * @param taskName Name of the background location task to stop.\n * @return A promise resolving as soon as the task is unregistered.\n */\nexport async function stopLocationUpdatesAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopLocationUpdatesAsync(taskName);\n}\n\n// @needsAudit\n/**\n * @param taskName Name of the location task to check.\n * @return A promise which fulfills with boolean value indicating whether the location task is\n * started or not.\n */\nexport async function hasStartedLocationUpdatesAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);\n}\n\n// --- Geofencing\n\nfunction _validateRegions(regions: LocationRegion[]) {\n  if (!regions || regions.length === 0) {\n    throw new Error(\n      'Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions'\n    );\n  }\n  for (const region of regions) {\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(`Region's latitude must be a number. Got '${region.latitude}' instead.`);\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\n        `Region's longitude must be a number. Got '${region.longitude}' instead.`\n      );\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(`Region's radius must be a number. Got '${region.radius}' instead.`);\n    }\n  }\n}\n\n// @needsAudit\n/**\n * Starts geofencing for given regions. When the new event comes, the task with specified name will\n * be called with the region that the device enter to or exit from.\n * If you want to add or remove regions from already running geofencing task, you can just call\n * `startGeofencingAsync` again with the new array of regions.\n * @param taskName Name of the task that will be called when the device enters or exits from specified regions.\n * @param regions Array of region objects to be geofenced.\n * @return A promise resolving as soon as the task is registered.\n *\n * # Task parameters\n *\n * Geofencing task will be receiving following data:\n *  - `eventType` - Indicates the reason for calling the task, which can be triggered by entering or exiting the region.\n *    See [GeofencingEventType](#geofencingeventtype).\n *  - `region` - Object containing details about updated region. See [LocationRegion](#locationregion) for more details.\n *\n * # Example\n * ```ts\n * import { GeofencingEventType } from 'expo-location';\n * import * as TaskManager from 'expo-task-manager';\n *\n *  TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { eventType, region }, error }) => {\n *   if (error) {\n *     // check `error.message` for more details.\n *     return;\n *   }\n *   if (eventType === GeofencingEventType.Enter) {\n *     console.log(\"You've entered region:\", region);\n *   } else if (eventType === GeofencingEventType.Exit) {\n *     console.log(\"You've left region:\", region);\n *   }\n * });\n * ```\n */\nexport async function startGeofencingAsync(\n  taskName: string,\n  regions: LocationRegion[] = []\n): Promise<void> {\n  _validateTaskName(taskName);\n  _validateRegions(regions);\n  await ExpoLocation.startGeofencingAsync(taskName, { regions });\n}\n\n// @needsAudit\n/**\n * Stops geofencing for specified task. It unregisters the background task so the app will not be\n * receiving any updates, especially in the background.\n * @param taskName Name of the task to unregister.\n * @return A promise resolving as soon as the task is unregistered.\n */\nexport async function stopGeofencingAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopGeofencingAsync(taskName);\n}\n\n// @needsAudit\n/**\n * @param taskName Name of the geofencing task to check.\n * @return A promise which fulfills with boolean value indicating whether the geofencing task is\n * started or not.\n */\nexport async function hasStartedGeofencingAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedGeofencingAsync(taskName);\n}\n\nexport { LocationEventEmitter as EventEmitter, _getCurrentWatchId };\n\nexport {\n  LocationAccuracy as Accuracy,\n  LocationActivityType as ActivityType,\n  LocationGeofencingEventType as GeofencingEventType,\n  LocationGeofencingRegionState as GeofencingRegionState,\n  PermissionStatus,\n  PermissionHookOptions,\n  setGoogleApiKey,\n};\n\nexport { installWebGeolocationPolyfill } from './GeolocationPolyfill';\nexport * from './Location.types';\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}